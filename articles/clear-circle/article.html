Очищаем произвольную фигуру с html5 Canvas

Однажды я видел вопрос о том, как очистить с Холста произвольную фигуру, например, круг. В api есть метод clearRect, но нету метода clear, потому решение этого вопроса - затруднительно. Автору того вопроса порекомендовали вместо того, чтобы просто очистить круг - залить всё, кроме круга необходимым цветом, но на самом деле есть более изящные решения.
	
Зачем вообще всё это нужно? Это может использоваться в графическом редакторе, чтобы добавить "резинку", это может использоваться <a href="http://habrahabr.ru/blogs/programming/104220/">в игре, чтобы сделать "области тьмы"</a> да и <a href="http://doseng.org/flash/65370-kak-na-samom-dele-vse-proishodit-v-klubah.html">много ещё чего</a>.

Конечно, теоретически решения можно найти и на самом деле все они на поверхности, но на практике люди городят ужасные костыли, которые имеют кучу недостатков. Итак, под катом - несколько решений и примеры кода.

<habracut />

<h2>Всё, кроме фигуры</h2>

Первое решение - пойти обратным путём. Не стирать круг, а рисовать всё кроме круга. Код <a href="http://jsfiddle.net/LSH36/2/">приблизительно такой</a>:

<source lang="javascript">
var ctx = $('canvas')[0].getContext('2d');
var canvas = ctx.canvas;

ctx.beginPath();
ctx.moveTo( 0, 0 );
ctx.lineTo( 0, canvas.height );
ctx.lineTo( canvas.width, canvas.height );
ctx.lineTo( canvas.width, 0 );
ctx.lineTo( 0, 0 );
ctx.arc( 50, 50, 25, 0, Math.PI * 2, false );
ctx.closePath();

ctx.fill();
</source>

Можно сделать даже два инвертированных круга, но если они будут пересекаться, то <a href="http://jsfiddle.net/LSH36/">место пересечения останется закрашенным</a>. Картинку можно залить при помощи <code>createPattern</code>.

<h4>Преимущества</h4>
* Можно очистить несколько не пересекающихся кругов
* Сглаженные границы
* На фоне может лежать картинка

<h4>Недостатки</h4>
* При пересечении кругов очищаются неправильно
* При любом изменении любой части (например, добавился ещё один круг) необходимо очистить и перерисовывать весь холст - низкая производительность
* Нельзя использовать для очистки холста после множества объектов (т.е. это сойдёт для игры с "областями тьмы", но не подойдёт в качестве ластика для графического редактора)
* Относительная сложность алгоритма - средняя

<h2>Всё, кроме фигуры + буффер</h2>

Предыдущий способ, модифицированный для решения проблем с производительностью. Решение - отрисовать инвертированную фигуру в буфер необходимого размера, при любых изменениях старую позицию фигуры заливать цветом, очищать при помощи clearRect позицию под новую фигуру. Код <a href="http://jsfiddle.net/LSH36/1/">приблизительно такой</a>:

<source lang="javascript">
var ctx = $('canvas')[0].getContext('2d');
var canvas = ctx.canvas;


var buffer = function () {
    var canvas = document.createElement('canvas');
    canvas.width  = 50;
    canvas.height = 50;

    var ctx = canvas.getContext('2d');

    ctx.beginPath();
    ctx.moveTo( 0, 0 );
    ctx.lineTo( 0, canvas.height );
    ctx.lineTo( canvas.width, canvas.height );
    ctx.lineTo( canvas.width, 0 );
    ctx.lineTo( 0, 0 );
    ctx.arc( 25, 25, 25, 0, Math.PI * 2, false );
    ctx.closePath();

    ctx.fill();

    return canvas;
}();

ctx.fillRect(0,0,canvas.width,canvas.height);
ctx.clearRect(25,25,buffer.width,buffer.height);
ctx.drawImage(buffer,25,25);
</source>

Способ очень маргинальный и, несмотря на повышенную производительность имеет ещё больше недостатков, чем предыдущий. Он себя хорошо покажет, если очищаться должен один круг статического размера на однородной подложке.

<h4>Преимущества</h4>
* Можно очистить несколько не пересекающихся кругов
* Очень быстрый для редких задач
* Сглаженные границы

<h4>Недостатки</h4>
* При пересечении кругов <a href="http://jsfiddle.net/LSH36/3/">очищаются неправильно</a>.
* Нельзя использовать для очистки холста после множества объектов (т.е. это сойдёт для игры с "областями тьмы", но не подойдёт в качестве ластика для графического редактора)
* Относительная сложность алгоритма - высокая, много кода
* На фоне нельзя использовать картинку, только однородный цвет
* При изменяемых размерах круга буффер не имеет смысла

<h2>Всё, кроме фигуры + ограниченное рамками</h2>
Способ аналогичный предыдущему, но мы отрисовываем не в буффер, а сразу в необходимый прямоугольник. Ещё сильнее повышается сложность, но этим мы можем даже решить ряд недостатков:
* Алгоритм будет хорошо работать даже если изменяется размер и вид фигуры
* Не используется буффер
* Можно очищать с неравномерного фона

Тем не менее, алгоритм всё равно сложен и не имеет смысла, потому идём дальше и не заморачиваемся с кодом.

<h2>Clip</h2>
http://jsfiddle.net/LSH36/4/
Этот способ ближе к реальности. Мы проходим фигуру, потом делаем clip и после - clearRect необходимого размера. Всё бы хорошо, да в Хроме clip работает особенно - без сглаживания:
<img src="http://habrastorage.org/storage1/e5d71e55/65d9297a/4dc81936/0b1eeac6.png"/>

Код очень прост:
<source lang="javascript">
var ctx = $('canvas')[0].getContext('2d');
var canvas = ctx.canvas;

ctx.fillRect(0,0,canvas.width,canvas.height);

ctx.beginPath();
ctx.arc( 50, 50, 25, 0, Math.PI * 2, false );
ctx.closePath();
ctx.clip();
ctx.clearRect(25, 25, 50, 50);
</source>

<h4>Преимущества</h4>
* Мы реально очищаем круг, а не рисуем всё вне круга, потому этот алгоритм универсален - может применятся в любом приложении

<h4>Недостатки</h4>
* В Хроме плохо работает сглаживание
* Необходимо знать точный размер boundingRectangle - дополнительные, хоть и незначительные, вычисления

<h2>globalCompositeOperation = 'destination-out'</h2>
Самый правильный, быстрый и лёгкий способ. На самом деле он столь универсален и хорош, что все предыдущие просто не имеют смысла.

Код - прекрасен
<source lang="javascript">
var ctx = $('canvas')[0].getContext('2d');
var canvas = ctx.canvas;

ctx.fillRect(0,0,canvas.width,canvas.height);

ctx.beginPath();
ctx.arc( 50, 50, 25, 0, Math.PI * 2, false );
ctx.closePath();
ctx.globalCompositeOperation = 'destination-out';
ctx.fill();
</source>

Или, на LibCanvas:
<source lang="javascript">
var ctx = atom.dom('canvas').first.getContext('2d-libcanvas');

ctx.fillAll( 'black' ).clear( new Circle(50, 50, 25) );
</source>

<h4>Преимущества</h4>
* Мы реально очищаем круг, а не рисуем всё вне круга, потому этот алгоритм универсален - может применятся в любом приложении
* Прекрасно работает во всех браузерах
* Не требуются дополнительные вычисления как в clip
* При необходимости можно очистить с пониженой силой, установив globalAlpha=0.5

<h4>Недостатки</h4>
* Для кое-каких приложений медленней, чем "Всё, кроме фигуры + буффер"
* Медленней, чем обычная очистка при помощи clearRect подобной по размеру фигуры.